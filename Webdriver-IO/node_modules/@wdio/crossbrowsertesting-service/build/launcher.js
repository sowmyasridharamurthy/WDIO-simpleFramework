"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("util");

var _perf_hooks = require("perf_hooks");

var _cbt_tunnels = _interopRequireDefault(require("cbt_tunnels"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/crossbrowsertesting-service');

class CrossBrowserTestingLauncher {
  constructor(options, caps, config) {
    this.options = options;
    this.config = config;
  }

  async onPrepare() {
    if (!this.options.cbtTunnel) {
      return;
    }

    this.cbtTunnelOpts = Object.assign({
      username: this.config.user,
      authkey: this.config.key,
      nokill: true
    }, this.options.cbtTunnelOpts);
    const obs = new _perf_hooks.PerformanceObserver(list => {
      const entry = list.getEntries()[0];
      log.info(`CrossBrowserTesting tunnel successfully started after ${entry.duration}ms`);
    });
    obs.observe({
      entryTypes: ['measure'],
      buffered: false
    });

    _perf_hooks.performance.mark('tbTunnelStart');

    await (0, _util.promisify)(_cbt_tunnels.default.start)(this.cbtTunnelOpts);
    this.tunnel = true;

    _perf_hooks.performance.mark('tbTunnelEnd');

    _perf_hooks.performance.measure('bootTime', 'tbTunnelStart', 'tbTunnelEnd');
  }

  onComplete() {
    if (!this.tunnel) {
      return;
    }

    return new Promise((resolve, reject) => _cbt_tunnels.default.stop(err => {
      if (err) {
        return reject(err);
      }

      return resolve('stopped');
    }));
  }

}

exports.default = CrossBrowserTestingLauncher;